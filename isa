#!/usr/bin/perl

use strict;
use warnings 'FATAL' => 'all';
use Getopt::Std;
use vars qw($opt_c);
getopts('c');

## To Do List ##
# Indexed addressing" $truc,X and $truc,Y
# Indirect addressing: ($truc))
# Pre- and post ($truc,X) ($truc),X
# https://www.masswerk.at/6502/6502_instruction_set.html

my $usage = '
Ian\'s Silly Assembler

usage: isa <file>
options:
  -c  copy-paste output [default is tabular]

syntax:
  line-based
  {address|instruction [parameter]}\s+;.*

; example
$300      ; write here
JSR $FC58 ; clear screen (absoulte syntax)
RTS       ; return
$320      ; write here
JSR $C000 ; get a key press into accumulator
STA $10C0 ; clear key strobe
ADC #$01  ; add 1 to character (immediate syntax)
JSR $FDED ; print character to screen
RTS       ;


';

die $usage if @ARGV == 0;

my %code = (
	'ADC' => {'i' => '69', 'z' => '65', 'a' => '6D'},
	'BEQ' => {'i' => 'F0'},
	'BNE' => {'i' => 'D0'},
	'CMP' => {'i' => 'C9', 'z' => 'C5', 'a' => 'CD'},
	'CPX' => {'i' => 'E0', 'z' => 'E4', 'a' => 'EC'},
	'CPY' => {'i' => 'C0', 'z' => 'C4', 'a' => 'CC'},
	'DEC' => {'z' => 'C6', 'a' => 'CE'},
	'DEX' => 'CA',
	'DEY' => '88',
	'INC' => {'z' => 'E6', 'a' => 'EE'},
	'INX' => 'E8',
	'INY' => 'C8',
	'JMP' => {'a' => '4C'},
	'JSR' => {'a' => '20'},
	'LDA' => {'i' => 'A9', 'z' => 'A5', 'a' => 'AD'},
	'LDX' => {'i' => 'A2', 'z' => 'A6', 'a' => 'AE'},
	'LDY' => {'i' => 'A0', 'z' => 'A4', 'a' => 'AC'},
	'RTS' => '60',
	'STA' => {'z' => '85', 'a' => '8D'},
	'STX' => {'z' => '86', 'a' => '8E'},
	'STY' => {'z' => '84', 'a' => '8C'},
	'TAX' => 'AA',
	'TAY' => 'A8',
	'TSX' => 'BA',
	'TXA' => '8A',
	'TXS' => '9A',
	'TYA' => '98',
);

my $add = '^\$(\w+)\s*;(.*)$';
my $uni = '^([A-Z]{3})\s*;(.*)$';
my $imm = '^([A-Z]{3}) #\$(\w{2})\s*;(.*)$';
my $zro = '^([A-Z]{3}) \$(\w{2})\s*;(.*)$';
my $abs = '^([A-Z]{3}) \$(\w{2})(\w{2})\s*;(.*)$';

open(my $fh, $ARGV[0]) or die;
my $mem;
while (<$fh>) {
	next if /^;/;
	next unless /\S/;
	if    (/$add/) {$mem = output($1)}
	elsif (/$uni/) {$mem += output($mem, $code{$1}, $2)}
	elsif (/$imm/) {$mem += output($mem, $code{$1}{'i'}, $2, $3)}
	elsif (/$zro/) {$mem += output($mem, $code{$1}{'z'}, $2, $3)}
	elsif (/$abs/) {$mem += output($mem, $code{$1}{'a'}, $3, $2, $4)}
	else           {die "not supported $_"}
}
print "\n" if $opt_c;

sub output {
	if (@_ == 1) {
		my ($mem) = @_;
		if ($opt_c) {print "$mem: "}
		return eval "0x$_[0]";
	} elsif (@_ == 3) {
		my ($mem, $ins, $rem) = @_;
		if ($opt_c) {print "$ins "; return 1}
		print join("\t", $mem, dec2hex($mem, $ins), $rem), "\n";
		return 1;
	} elsif (@_ == 4) {
		my ($mem, $ins, $arg, $rem) = @_;
		if ($opt_c) {print "$ins $arg"; return 2}
		# stopped here
	}
	return undef
}

sub hex2dec {
	if (@_ == 1) {return eval "0x$_[0]"}
	my @s;
	foreach my $val (@_) {push @s, eval "0x$val"}
	return @s;
}

sub dec2hex {
	if (@_ == 1) {return sprintf("%X", $_[0])}
	my @s;
	foreach my $val (@_) {push @s, sprintf("%X", $val)}
	return @s;
}